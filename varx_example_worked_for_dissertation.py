# -*- coding: utf-8 -*-
"""VARX example worked for dissertation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SoVdF_oj3C1-T9slAzTNrqWkqBQQ0XuE
"""

# The relevant environment is varx

# Generate a simple vascular relationship network, then try to infer it back using vector autoregression

'''
import tifffile as tf
from scipy import io as sio
from scipy import signal
import numpy as np
import os
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, find_peaks_cwt
import zarr
from numcodecs import Blosc, Zstd 
'''
	
# VAR example
from statsmodels.tsa.vector_ar.var_model import VAR
#from random import random
from numpy.random import default_rng
#import zarr
import numpy as np
#from numcodecs import Blosc, Zstd 
from scipy import stats, signal
import matplotlib.pyplot as plt
import pickle
import os

rng = default_rng()

num_time_samples = 60000 # 30000 # 4000 # 3000#
num_vessels = 8 # start with a oversimplified network composed of 8 vessel segments and two bifurcations as depicted above. Blood flow in vessels 0,1,5 is measurable and is driven by blood flow in vessels 2,6 
sampling_frequency_hz = float(30) # 30 volumes per second smoothed to 10 samples per second
rbc_velocity = 4.5 # start with a constant velocity of red blood cells across the entire network. RBC transit time and inter-vascular latency are dictated by vascular distance d (t=d/v_rbc), with no dispersion.
heartbeat_frequency_hz = float(10)*0.01 # should be 10Hz Â± 5Hz. Here changed to artificially lower values to satisfy sufficient sampling

num_training_samples = 10000 # 1500 # 1500 # 5000
num_estimated_time_steps = 1500 # num_estimated_time_steps must be smaller than num_time_samples

#step_sample_time = 2500 # model a step function that starts at this sample

'''
# contrived dataset with dependency
data = list()

for j in range(num_time_samples):
    v1 = np.divide(j , num_time_samples) + 1e-1*random() + np.sin(2*np.pi*sampling_frequency_hz*j)
    v2 = 0.5*v1 + 1e-1*random()
    row = [v1, v2]
    data.append(row)
'''

#time_vector = np.linspace(0, num_time_samples*sampling_frequency_hz,num_time_samples)
'''
v1 = np.sin(2*np.pi*sampling_frequency_hz*time_vector*0.03) + 2
v1 += 0.2* (1 + np.random.randn(*v1.shape))
print(v1)
print(stats.describe(v1))
lag_value = 20 * sampling_frequency_hz
v2 = 0.5*np.roll(v1,lag_value) + 1e-0*random()
cbf = np.transpose( np.stack((v1,v2))   )
plt.plot(time_vector,cbf)
plt.show()
used_cbf = cbf[lag_value:-lag_value,:]
forecast_time_vector = time_vector[-lag_value] + time_vector
short_time_vector = time_vector[lag_value:-lag_value]
print(cbf.shape)
'''


'''

def save_dataset(save_file_name,group_name,dataset):
    root = zarr.open_group(save_file_name, mode='w')
    fill_me = root.require_group(group_name)
    root[group_name] = dataset

zarr.storage.default_compressor = Zstd(level=3)
compressor = Blosc(cname='zstd', clevel=3, shuffle=Blosc.BITSHUFFLE)

'''

#vascular_lengths = np.abs(rng.normal(30, 10, size=(num_vessels,)))
vascular_lengths = np.abs(rng.normal(80, 30, size=(num_vessels,)))
#vascular_lengths = np.abs(rng.normal(10, 30, size=(num_vessels,)))


#vascular_lengths = np.abs(np.random.normal(5, 1, size=(num_vessels,)))

print(f'vascular_lengths are {vascular_lengths}')

#vascular_latency_vector = np.rint((vascular_lengths*sampling_frequency_hz / rbc_velocity), dtype='int64')
vascular_latency_vector = np.rint(vascular_lengths * sampling_frequency_hz * np.reciprocal(rbc_velocity)).astype('int64')
print(f'vascular_latency_vector is {vascular_latency_vector}')

vascular_latency_matrix = np.zeros((num_vessels,num_vessels), dtype='int64')
vascular_coupling_matrix = np.zeros((num_vessels,num_vessels))


### Build vascular relationship network
#       ___2___
#     1/       \ 3
#__0__/         \____4___
#     \         / 
#     5\___6___/ 7
#

vessel_names = ('Output vein' , 'Venule (a)', 'Capillary (a)' , 'Arteriole (a)', 'Artery', 'Venule (b)', 'Capillary (b)', 'Arteriole (b)')

max_time_in_seconds = np.divide(num_time_samples,sampling_frequency_hz)
print(f'max time is {max_time_in_seconds}')
print(f'step size is {np.reciprocal(sampling_frequency_hz)}')

time_vector = np.arange(0, max_time_in_seconds, np.reciprocal(sampling_frequency_hz) )
pre_filtered_time_vector = np.arange(-max_time_in_seconds*0.5, max_time_in_seconds, np.reciprocal(sampling_frequency_hz) )
#print(time_vector)


vascular_latency_matrix[0,1] = vascular_latency_vector[1]
vascular_latency_matrix[1,2] = vascular_latency_vector[2]
vascular_latency_matrix[2,3] = vascular_latency_vector[3]
vascular_latency_matrix[3,4] = vascular_latency_vector[4]
vascular_latency_matrix[7,4] = vascular_latency_vector[4]
vascular_latency_matrix[0,5] = vascular_latency_vector[5]
vascular_latency_matrix[5,6] = vascular_latency_vector[6]
vascular_latency_matrix[6,7] = vascular_latency_vector[7]

vascular_coupling_matrix[0,1] = 0.74
vascular_coupling_matrix[1,2] = 0.9
vascular_coupling_matrix[2,3] = 0.7
vascular_coupling_matrix[3,4] = 0.83
vascular_coupling_matrix[7,4] = 0.94
vascular_coupling_matrix[0,5] = 0.6
vascular_coupling_matrix[5,6] = 0.8
vascular_coupling_matrix[6,7] = 0.52

higher_order_latencies = np.zeros((vascular_coupling_matrix.shape[0], vascular_coupling_matrix.shape[1], 5))
higher_order_couplings = np.zeros((vascular_coupling_matrix.shape[0], vascular_coupling_matrix.shape[1], 5))

## unforgivable hard-coding:
higher_order_latencies[:,:,0] = vascular_latency_matrix

higher_order_latencies[2,4,1] = higher_order_latencies[2,3,0] + higher_order_latencies[3,4,0]
higher_order_latencies[1,3,1] = higher_order_latencies[1,2,0] + higher_order_latencies[2,3,0]
higher_order_latencies[0,2,1] = higher_order_latencies[0,1,0] + higher_order_latencies[1,2,0]

higher_order_latencies[6,4,1] = higher_order_latencies[6,7,0] + higher_order_latencies[7,4,0]
higher_order_latencies[5,7,1] = higher_order_latencies[5,6,0] + higher_order_latencies[6,7,0]
higher_order_latencies[0,6,1] = higher_order_latencies[0,5,0] + higher_order_latencies[5,6,0]



higher_order_latencies[1,4,2] = higher_order_latencies[1,2,0] + higher_order_latencies[2,3,0] + higher_order_latencies[3,4,0]
higher_order_latencies[0,3,2] = higher_order_latencies[0,1,0] + higher_order_latencies[1,2,0] + higher_order_latencies[2,3,0] 

higher_order_latencies[5,4,2] = higher_order_latencies[5,6,0] + higher_order_latencies[6,7,0] + higher_order_latencies[7,4,0]
higher_order_latencies[0,7,2] = higher_order_latencies[0,5,0] + higher_order_latencies[5,6,0] + higher_order_latencies[6,7,0]

higher_order_latencies[0,4,3] = higher_order_latencies[0,1,0] + higher_order_latencies[1,2,0] + higher_order_latencies[2,3,0] + higher_order_latencies[3,4,0]

higher_order_latencies[0,4,4] = higher_order_latencies[0,5,0] + higher_order_latencies[5,6,0] + higher_order_latencies[6,7,0] + higher_order_latencies[7,4,0] # this is actually a third-order coupling just like the former one


## unforgivable hard-coding:
higher_order_couplings[:,:,0] = vascular_coupling_matrix


higher_order_couplings[:,:,1] = np.matmul(vascular_coupling_matrix,vascular_coupling_matrix)
higher_order_couplings[:,:,2] = np.matmul(higher_order_couplings[:,:,1],vascular_coupling_matrix)


higher_order_couplings[0,4,3] = higher_order_couplings[0,1,0] * higher_order_couplings[1,2,0] * higher_order_couplings[2,3,0] * higher_order_couplings[3,4,0]

higher_order_couplings[0,7,4] = higher_order_couplings[0,5,0] * higher_order_couplings[5,6,0] * higher_order_couplings[6,7,0] * higher_order_couplings[7,4,0] # this is actually a third-order coupling just like the former one




'''

for n in range(higher_order_couplings.shape[2]):
  print(higher_order_latencies[:,:,n])
  print('\\')
for n in range(higher_order_couplings.shape[2]):
  print(higher_order_couplings[:,:,n])
  print('\\')  

sheer_matrix_multiplication = np.matmul(vascular_coupling_matrix,vascular_coupling_matrix)
sheer_matrix_multiplication2 = np.matmul(sheer_matrix_multiplication,vascular_coupling_matrix)
sheer_matrix_multiplication3 = np.matmul(sheer_matrix_multiplication2,vascular_coupling_matrix)

print('sheer_matrix_multiplication is')
print(sheer_matrix_multiplication)
print('sheer_matrix_multiplication 2 is')
print(sheer_matrix_multiplication2)
print('sheer_matrix_multiplication 3 is')
print(sheer_matrix_multiplication3)'''

#vascular_coupling_matrix = vascular_coupling_matrix * 3


sos = signal.butter(4,0.15, 'low', output='sos', fs=sampling_frequency_hz)

sos_broader = signal.butter(4,2, 'low', output='sos', fs=sampling_frequency_hz)


cbf = np.ones((num_vessels,time_vector.shape[0])) # each line is a vessel, each column is a step in time

raw_input_cbf = 1 + np.abs(rng.normal(50, 10, size=pre_filtered_time_vector.shape))

input_cbf = 13*signal.sosfilt(sos, raw_input_cbf) + signal.sosfilt(sos_broader, raw_input_cbf)

fig0,ax0 = plt.subplots(2,2)

ax0[0,0].plot(pre_filtered_time_vector,raw_input_cbf)
ax0[0,0].plot(pre_filtered_time_vector,input_cbf)
ax0[0,0].set_title('input cbf before and after low pass filtering')
#plt.show()


#cbf[4,:] = np.sin(2*np.pi*heartbeat_frequency_hz*time_vector) + 2 
#cbf[4,:] += 0.4* (1 + np.random.randn(*cbf[4,:].shape))
cbf[4,:] = input_cbf[-len(time_vector):]
#cbf[4,step_sample_time:] += 0.2 * np.max(cbf[4,:])


cbf[3,:] = vascular_coupling_matrix[3,4] * np.roll(cbf[4,:], vascular_latency_matrix[3,4])
cbf[7,:] = vascular_coupling_matrix[7,4] * np.roll(cbf[4,:], vascular_latency_matrix[7,4])

cbf[2,:] = vascular_coupling_matrix[2,3] * np.roll(cbf[3,:], vascular_latency_matrix[2,3])
cbf[6,:] = vascular_coupling_matrix[6,7] * np.roll(cbf[7,:], vascular_latency_matrix[6,7])

#cbf[2,:]= np.random.randn(1,num_time_samples) * rng.random() + (10*rng.random()) 
#cbf[6,:]= np.random.randn(1,num_time_samples) * rng.random() + (10*rng.random())

cbf[1,:] = vascular_coupling_matrix[1,2] * np.roll(cbf[2,:], vascular_latency_matrix[1,2])
cbf[5,:] = vascular_coupling_matrix[5,6] * np.roll(cbf[6,:], vascular_latency_matrix[5,6])

c01 = vascular_coupling_matrix[0,1] * np.roll(cbf[1,:], vascular_latency_matrix[0,1])
c05 = vascular_coupling_matrix[0,5] * np.roll(cbf[5,:], vascular_latency_matrix[0,5])
cbf[0,:] = c01 + c05


ax0[0,1].plot(time_vector, np.transpose(cbf))
#plt.show()

filtered_cbf = signal.sosfilt(sos_broader, cbf, axis=1)
#filtered_cbf = cbf

#sos = signal.butter(4, 0.3, 'low', output='sos', fs=sampling_frequency_hz)


#fitted_vessel_indices = [0, 1, 5]
#fitted_vessel_indices = [1,2,3]
#fitted_vessel_indices = [0, 4]
fitted_vessel_indices = [0,1,2,3,4,5,6,7]

#fitted_vessel_indices = [0,1,2,3,5,6,7]

#fitted_vessel_indices = [4,3,2,1,7,6,5,0]
#fitted_vessel_indices = [4,3,1,7,5,0]




fitted_vessel_labels = []
for boompam in fitted_vessel_indices:
  fitted_vessel_labels.append(vessel_names[boompam])
print('fitted_vessel_labels are: ')
print(fitted_vessel_labels)

#filtered_cbf = cbf

minimal_lag = np.min(vascular_latency_vector[fitted_vessel_indices])
maximal_lag = np.max(vascular_latency_vector[fitted_vessel_indices])
print(f'minimal lag is {minimal_lag} samples')

start_from = minimal_lag + 100
end_at = num_training_samples # -100

#t_vec = np.linspace(0,num_time_samples/sampling_frequency_hz, num_time_samples)
cbf = cbf.T
filtered_cbf = filtered_cbf.T



used_cbf = filtered_cbf[start_from:end_at,fitted_vessel_indices]
short_time_vector = time_vector[start_from:end_at]
forecast_time_vector = time_vector[end_at] + time_vector[:num_estimated_time_steps]

#plt.plot(t_vec[start_from:], cbf[start_from:,:])
ax0[1,0].plot(short_time_vector,used_cbf)

#plt.show()

print(f'The number of nan values in used_cbf is {np.sum(np.isnan(used_cbf[:]))}')

#data = list()
#data.append(cbf)

# print(data)

print(f'shape of used_cbf is {used_cbf.shape}')
print(used_cbf)

# adding measurement noise
measurement_noise_amplitude = np.mean(used_cbf.flatten()) * 0.0001  * 0.0001  * 0.000000001 * 0.01
#measurement_noise_amplitude = 0
measurement_noise = measurement_noise_amplitude * rng.normal(0, 1000, size=used_cbf.shape)
measurement_noise += -measurement_noise.min() # shifting additive noise to be non-negative

plt.hist(measurement_noise.flatten(),bins=100)

#noisy_cbf_measurement = used_cbf + measurement_noise # the model mostly fails even if 0 noise is added - figure out why!
noisy_cbf_measurement = used_cbf

plt.plot(short_time_vector,noisy_cbf_measurement)
plt.show()

# fit model
model = VAR(noisy_cbf_measurement)
#model = VAR(used_cbf)
max_lag_inflation_factor = 3.0 # 1.5 # 1.8 
model_fit = model.fit(maxlags=int(maximal_lag * max_lag_inflation_factor))
model_parameters = model_fit.params
#print(model_parameters)
print(model_parameters.shape)
#plt.close()

plt.close()

def label_contributions(input_ax, fitted_vessel_index,other_vessel_index, text_reference_height=None):
  for higher_order_index in range(higher_order_latencies.shape[2]):
    if(higher_order_latencies[fitted_vessel_index,other_vessel_index,higher_order_index]):
      print()
      me_latency = np.squeeze( higher_order_latencies[fitted_vessel_index,other_vessel_index,higher_order_index] )
      #print(f'me_latency = {me_latency}') # debug
      x = time_vector[ int( me_latency )  ]
      #x = int( me_latency )
      #x = 30 # debug
      #y = 0.1 * higher_order_couplings[fitted_vessel_index,other_vessel_index,higher_order_index]
      if(text_reference_height):
        y = 1.5 * text_reference_height
      else:
        y = higher_order_couplings[fitted_vessel_index,other_vessel_index,higher_order_index]
      shown_text = '$' + vessel_names[other_vessel_index] + '$'
      #shown_text = vessel_names[other_vessel_index]
      print(f'x = {x}, y = {y}, shown_text = ' + shown_text)
      #input_ax.text(time_vector[higher_order_latencies[fitted_vessel_index,other_vessel_index,higher_order_index] ], , vessel_names[other_vessel_index], fontsize=15, color = 'C' + str(other_vessel_index), ha='center'  )
      #input_ax.text(x, y , shown_text, fontsize=15, color = 'C' + str(other_vessel_index), ha='center'  )
      #input_ax.annotate(shown_text, (x, y), xycoords='data', fontsize=15, color = 'C' + str(other_vessel_index)  )
      if x < num_fitted_lags:
        input_ax.plot(x,y, marker=shown_text, markersize=50, color = 'C' + str(other_vessel_index))
      ###input_ax.plot(x,y, (3+higher_order_index, 1, 0), markersize=10, color = 'C' + str(other_vessel_index))
      #(numsides, 1, angle)




num_fitted_vessels = model_parameters.shape[1]

num_fitted_lags = int( np.divide(model_parameters.shape[0]-1, num_fitted_vessels) )

rehsaped_model_parameters = np.reshape(model_parameters[1:,:], (num_fitted_lags,num_fitted_vessels,num_fitted_vessels))

fig3,ax4 = plt.subplots(num_fitted_vessels,1, sharex='col', sharey='row',figsize=(20, 29))

show_my_subplots_in_this_order = np.argsort([4,3,2,1,5,6,7,0])

for fitted_vessel_num in fitted_vessel_indices:
  subplot_index = show_my_subplots_in_this_order[fitted_vessel_num]
  #ax4[fitted_vessel_num].plot(np.arange(num_fitted_lags), rehsaped_model_parameters[:,fitted_vessel_num,:] )
  for other_vessel_num in fitted_vessel_indices:
      
    '''
    if(vascular_latency_matrix[fitted_vessel_num,other_vessel_num]):
      #ax4[subplot_index].plot(time_vector[vascular_latency_matrix[fitted_vessel_num, other_vessel_num] ], vascular_coupling_matrix[fitted_vessel_num, other_vessel_num] , '*', markersize=10, color = 'C' + str(other_vessel_num)  )
      ax4[subplot_index].text(time_vector[vascular_latency_matrix[fitted_vessel_num, other_vessel_num] ], vascular_coupling_matrix[fitted_vessel_num, other_vessel_num] , vessel_names[other_vessel_num], fontsize=20, color = 'C' + str(other_vessel_num), ha='center'  )
    '''
    max_val = np.max(rehsaped_model_parameters[:,other_vessel_num,fitted_vessel_num]) # measuring the maximal value of each coupling, so as to be place the label not too high above it
    label_contributions(ax4[subplot_index], fitted_vessel_num,other_vessel_num,  max_val)  
    vascular_label = fitted_vessel_labels[other_vessel_num]
    #ax4[fitted_vessel_num].plot(np.arange(num_fitted_lags), rehsaped_model_parameters[:,fitted_vessel_num,other_vessel_num], color = 'C' + str(other_vessel_num), label = str(other_vessel_num) )
    #ax4[fitted_vessel_num].plot(np.arange(num_fitted_lags), rehsaped_model_parameters[:,other_vessel_num,fitted_vessel_num], color = 'C' + str(other_vessel_num), label = vascular_label )
    ax4[subplot_index].plot(time_vector[:num_fitted_lags], rehsaped_model_parameters[:,other_vessel_num,fitted_vessel_num], color = 'C' + str(other_vessel_num), label = vascular_label )
    
  #ax4[fitted_vessel_num].set_title()
  #if fitted_vessel_num == 0:
  #  ax4[fitted_vessel_num].legend(ncol=4)

  print(f'fitted_vessel_num is {fitted_vessel_num}, num_fitted_vessels is {num_fitted_vessels}')

  
    
  #ax4[fitted_vessel_num].set_title( str(vascular_latency_matrix[fitted_vessel_num,:].flatten()))
  ax4[subplot_index].set_title( f'simulated (*) vs. fitted lags for {fitted_vessel_labels[fitted_vessel_num]}')
ax4[num_fitted_vessels  - 1].set_xlabel('Time [seconds]')
ax4[0].legend(ncol=4)



'''
#non_neglible_parameter_threshold = 0.05
return_k_largest_indices = 4 # return the k largest indices for each vessel fit
for fitted_vessel_num in range(model_parameters.shape[1]):
  non_neglible_parameter_indices = np.argwhere(model_parameters[:,fitted_vessel_num]>non_neglible_parameter_threshold)
  non_neglible_parameter_indices = np.argpartition(model_parameters[:,fitted_vessel_num], -return_k_largest_indices)[-return_k_largest_indices:]
  print(f'for fitted_vessel {fitted_vessel_num} the non_neglible_parameter_times are {time_vector[non_neglible_parameter_indices]} and their values are {model_parameters[non_neglible_parameter_indices,fitted_vessel_num]}')
print(f'vascular_latency_vector is {vascular_latency_vector}')f
print(f'vascular_latency_vector - minimal_lag is {vascular_latency_vector - minimal_lag}')
'''

#for t in range(num_estimated_time_steps): # commented out by LG 2021_08_12
  
  


# make prediction
#print(model_fit.summary())

fig5,ax5 = plt.subplots(0,0)

#irf_thingy = model_fit.irf
#print(irf_thingy)
#irf_thingy().plot(impulse=2,response=0)


#yhat = model_fit.forecast(model_fit.endog_lagged, steps=num_estimated_time_steps)
#yhat = model_fit.simulate_var(steps=num_estimated_time_steps)
#yhat = model.predict(model_fit, filtered_cbf)

#print(yhat)
#plt.plot(time_vector[start_from:],filtered_cbf[start_from:,:],alpha=0.5)
#plt.plot(forecast_time_vector,yhat,alpha=0.5)
plt.show()

print('all done')